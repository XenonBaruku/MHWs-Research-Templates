//------------------------------------------------
//--- 010 Editor v15.0.1 Binary Template
//
//      File: MHWs_jcns.bt
//   Authors: XenonValstrax
//   Version: 0.3c
//   Purpose: Parsing MHWilds Joint Constraints (*.jcns) files
//  Category: MHWilds
// File Mask: *.jcns.*
//  ID Bytes: 
//   History: 
//------------------------------------------------
// - STILL WIP -
//  TODO:
//      1) Function:  Constraints editing
//      2) Structure: Parsing the rest stuff
//      3) Function: Full unicode support for Hash generate
//      


local string mode;

//—————————————————/* - TYPES - */—————————————————//
// AXIS_XYZ
typedef struct
{
    float X <name="Axis X", fgcolor=0x5042FF, bgcolor=0x000070>;
    float Y <name="Axis Y", fgcolor=0x00FF00, bgcolor=0x007000>;
    float Z <name="Axis Z", fgcolor=0xFFAA50, bgcolor=0x700000>;
} 
AXIS_XYZ <read=Str("[%.3f, %.3f, %.3f]", X, Y, Z)>;

// AXIS_XYZW
typedef struct
{
    float X <name="Axis X", fgcolor=0x5042FF, bgcolor=0x000070>;
    float Y <name="Axis Y", fgcolor=0x00FF00, bgcolor=0x007000>;
    float Z <name="Axis Z", fgcolor=0xFFAA50, bgcolor=0x700000>;
    float W <name="Axis W", fgcolor=0xFFFFFF, bgcolor=0x700000>;
} 
AXIS_XYZW <read=Str("[%.3f, %.3f, %.3f, %.3f]", X, Y, Z, W)>;

// WStringOffset
typedef struct 
{
    uint64 WStrOffset;
    local uint64 ReturnPos = FTell();
    FSeek(WStrOffset);
    wstring WString <bgcolor=0x666666, fgcolor=0xFF00FA>; //<fgcolor=0xFFBB70>;
    FSeek(ReturnPos);
} 
WStringOffset <read=WString, optimize=false>;

typedef int hash <read=Str("%X", this), write="">;



//———————————————/* - FUNCTIONS - */———————————————//

void AddConstraint(wstring BoneNames)
{
    Printf("%s\n", BoneNames);
    local byte ObjectName;
    
    local uint _;
    local uint __;
    local uint item = 0;
    local byte buffer[1024];
    for (_ = 0; _ < WStrlen(BoneNames); ++_)
    {
        if (BoneNames[_] != 0x3b && item < 1 ) { buffer[_] = BoneNames[_]; } 
        else if (BoneNames[_] == 0x3b && item == 1)
        {
            for (__ = 0; __ < Strlen(buffer); ++__)
            {
                ObjectName[__] = buffer[__];
            }
            ++item;
        }
    }
    Printf("%s, %d\n", Str(ObjectName), WStrlen(ObjectName));
};


// Function ConvertBytesToInts - from ConvertBytesToInts.1sc
// Credit: Artur Babecki
int64 ConvertBytesToInts (char type[],char dat[],int n)
{
    //  type[] - target type ("short","int","int64")
    //   dat[] - array of bytes
    //      n  - starting position in the array
    // result  - int64  - do cast (short),(int),(FILETIME) etc. after invoking function
    //                    for other  data types   
    local int i,size;
    local int64 value;
    switch(type)
      {
        case "short":  size=sizeof(int); break;
        case "int":   size=sizeof(int); break;
        case "int64": size=sizeof(int64); break;
        default:    default: 
        MessageBox( idCancel,"ConvertBytesToInts ()", "wrong data type specified : "+type);Exit(-1);
        Printf("Wrong data type in conversion\n");return 0;
     }
    
    if(sizeof(dat)<n+size) {  MessageBox( idCancel,"ConvertBytesToInts ()","request out of array");Exit(-1);}
    
    
    if(IsLittleEndian())
        for( i = 0; i <size; i++ )
        {
        value = (value << 8) + (uchar)dat[size-i+n-1];
        }
    else
        for(i=size;i>0;i--)   
        {value = (value << 8) + (uchar)dat[size-i+n];}
    return value;
}

uint32 fmix32(uint32 h) 
{
    h ^= h >> 16;
    h *= 0x85ebca6b;
    h ^= h >> 13;
    h *= 0xc2b2ae35;
    h ^= h >> 16;
    return h;
}

uint32 murmur3_32(wstring key)
{
    local uint32 c1 = 0xcc9e2d51;
    local uint32 c2 = 0x1b873593;
    local uint32 n = 0xe6546b64;
    local uint32 len = WStrlen(key) * 2;
    local byte data[len];
    
    local uint32 __;
    for (__ = 0; __ < len; __++)
    {
        if (__ % 2 != 0)
        {
            data[__] = 0;
        }
        else
        {
            data[__] = key[__ - __ / 2];
        }
    }
    
    local uint32 nblocks = len / 4;
    local uint32 k1;
    
    local uint32 h1 = 0xFFFFFFFF;
    
    local byte kb[4] = 0;
    local int ki;
    local uint32 i;
    for (i = 0; i < nblocks; i++) 
    {
        kb[2] = (data[i * 4 + 2]);
        ki = ConvertBytesToInts("int", kb, 0);
        k1 = (data[i * 4 + 3] ) | ki | (data[i * 4 + 1]) | data[i * 4 + 0];
        k1 *= c1;
        k1 = (k1 << 15) | (k1 >> 17);
        k1 *= c2;
        h1 ^= k1;
        h1 = (h1 << 13) | (h1 >> 19);
        h1 = h1 * 5 + 0xe6546b64;
    }

    local uint32 tail_index = nblocks * 4;
    k1 = 0;
    switch (len & 3) 
    {
        case 3: k1 ^= data[tail_index + 2] << 16;
        case 2: k1 ^= data[tail_index + 1] << 8;
        case 1:
            k1 ^= data[tail_index + 0];
            k1 *= c1;
            k1 = (k1 << 15) | (k1 >> 17);
            k1 *= c2;
            h1 ^= k1;
    }
    h1 ^= len;
    h1 = fmix32(h1);

    return h1;
}



//————————————————/* - STRUCTS - */————————————————//
// struct ConstraintTarget
typedef struct
{
    uint64 OffsetConstraintData;
    local uint ReturnPos = FTell();
    FSeek(OffsetConstraintData);
    uint64 UnkINT64CI0 <name="UnknownINT64">;
    WStringOffset Target <name="Target: Name">;
    hash TargetHash <name="Target: Hash", comment="Maybe bone hash.">;
    uint UnknownINT32;
    uint64 UnkINT64CI1 <name="UnknownINT64", comment="Usually 771.">;
    AXIS_XYZ UnknownAxis;
    AXIS_XYZ UnknownAxis;
    AXIS_XYZW UnknownAxisQutermion;
    local string readStr;
    local hash readHash = murmur3_32(Target.WString);
    SPrintf(readStr, "%s - %X", Target.WString, readHash);
    wstring ConstraintTarget <name="Target: Name", bgcolor=0x666666, fgcolor=0xFF00FA>;
    FSeek(ReturnPos);
} 
ConstraintTarget <read=readStr>;

// struct ConstraintSet
typedef struct
{
    uint64 UnkINT64CS0 <name="UnknownINT64">;
    ConstraintTarget CTarget <name="Constraint: Target">;
    WStringOffset ConstraintName <name="Object: Name">;
    uint64 PropertyOffset;
    hash ObjectHash <name="Object: Hash", comment="Read from file.">;
    hash PropertyHash <name="Property: Hash", comment="Material properties, etc.">;
    uint8 _UnknownByte0;
    uint8 TargetAmount;
    uint8 TransformationID;
    uint8 _UnknownByte1;
    uint8 AxisID;
    uint8 _UnknownByte2;
    uint8 _UnknownByte3;
    uint8 _UnknownByte4;
    float _UnknownFloat[3];
    AXIS_XYZ _UnknownVector;
    uint64 UnknownINT64CS2[1] <name="UnknownINT64">;
    local string readStr;
    local hash readHash = murmur3_32(ConstraintName.WString);
    SPrintf(readStr, "%s - %s [%X,%X]", ConstraintName.WString, CTarget.Target.WString, readHash, CTarget.readHash);
} 
Constraint <read=readStr>;

// struct ConstraintList
typedef struct 
{
    byte CnsInput <name="Input bones here to add a new constraint...", read="Example: ObjectName;TargetName1;TargetName2;...", write=AddConstraint(Str(value))>;
    FSkip(-1);
    local uint _ = 0;
    for (_; _<header.ConstraintAmount; ++_)
    {
        Constraint Cns <name="ConstraintSet">;
    }
} 
ConstraintList <read=header.ConstraintAmount>;


// struct Reference
typedef struct
{
    uint64 Offset;
    uint64 BoneCount;
    if (Offset != 0)
    {
        local uint ReturnPos = FTell();
        FSeek(Offset);
        hash TargetHash;
        local uint _ = 0;
        for (_; _<BoneCount; ++_)
        {
            hash BoneHash;
        }
        local string readStr;
        SPrintf(readStr, "%X - %X", BoneHash, TargetHash);
        FSeek(ReturnPos);
    }
} 
Reference <read=readStr>;

// struct ReferenceList
typedef struct
{
    byte RefInput <name="Input here to add a new reference...", read="ObjectHash - TargetHash">;
    FSkip(-1);
    local uint _ = 0;
    for (_; _<header.ReferenceAmount; ++_)
    {
        Reference Ref <name="Reference">;
    }
} 
ReferenceList <read=header.ReferenceAmount>;



//———————————————/* - STRUCTURES - */———————————————//
// HEADER
typedef struct
{
    struct TAG
    {
        uint version;
        byte type[4];
        uint64 _unkINT1;
        uint64 _unkOffset1;
        uint64 _unkINT1_1 <comment="ID?">;
        uint64 TableOffset;
        uint64 _unkINT1_2 <comment="ID?">;
        FSeek(_unkOffset1);
        uint64 _unkINT2;
        uint64 _unkINT2_1;
        FSeek(TableOffset);
        uint64 RecordOffset;
        uint64 _unkINT2_2;
    } Tags <comment="Usually unnecessary to modify.">;
    FSeek(Tags.RecordOffset);
    uint64 EndOfHeader;
    uint64 BodyOffset;
    uint64 EndOfBody;
    uint64 UnknownINT64[7] <hidden=true>;
    uint64 SectionOffset;
    uint64 ReferenceTableOffset;
    short _UnknownUINT16;
    short ConstraintAmount;
    short ReferenceAmount;
    short _UnknownShorts[7] <hidden=true>;
    uint8 SectionAmount;
    local uint64 returnPos = FTell();
    FSeek(SectionOffset);
    local uint8 _;
    for (_; _<SectionAmount; ++_) { uint Section; };
    FSeek(returnPos);
    byte UnknownBytes[11] <hidden=true>;
    local string readStr;
} HEADER <name="JCNS Header", read=Str("VERSION %u", Tags.version)>;

// BODY
typedef struct 
{
    if (header.ConstraintAmount > 0)
    {
        ConstraintList ConstraintSets;
        FSeek(header.ReferenceTableOffset);
    }
    if (header.ReferenceAmount > 0)
    {
        FSeek(header.ReferenceTableOffset);
        ReferenceList References;
    }
} BODY <name="JCNS Body", fgcolor=0xFFBD9A, open=true>;



//—————————————————/* - FILES - */—————————————————//
HEADER header;
if (header.Tags.version == 29) //MHWs
{
    mode = "MHWs";
    if (header.ConstraintAmount > 0)
    {
        FSeek(header.BodyOffset);
        BODY body;
    }
    
}
if (header.Tags.version == 21) //MHRS
{
    mode = "MHRS";
}
